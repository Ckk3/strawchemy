# Do not edit this file directly. It has been autogenerated from
# src/strawchemy/sqlalchemy/repository/_async.py
from __future__ import annotations

from collections import defaultdict
from typing import TYPE_CHECKING, Any, TypeVar

from sqlalchemy import Row, insert, inspect, update
from sqlalchemy.orm import NO_VALUE, RelationshipProperty
from strawchemy.graphql.mutation import InputData, RelationType
from strawchemy.sqlalchemy._executor import QueryResult, SyncQueryExecutor
from strawchemy.sqlalchemy.typing import AnySyncSession, DeclarativeT, SQLAlchemyQueryNode

from ._base import SQLAlchemyGraphQLRepository

if TYPE_CHECKING:
    from collections.abc import Sequence

    from sqlalchemy.orm import DeclarativeBase, QueryableAttribute
    from strawchemy.graphql.dto import BooleanFilterDTO, EnumDTO, OrderByDTO
    from strawchemy.sqlalchemy.hook import QueryHook


__all__ = ()

T = TypeVar("T", bound=Any)


class SQLAlchemyGraphQLSyncRepository(SQLAlchemyGraphQLRepository[DeclarativeT, AnySyncSession]):
    def _to_dict(self, model: DeclarativeBase) -> dict[str, Any]:
        loaded_attr = {name for name, attr in inspect(model).attrs.items() if attr.loaded_value is not NO_VALUE}
        return {field: getattr(model, field) for field in model.__mapper__.columns.keys() if field in loaded_attr}  # noqa: SIM118

    def _connect_to_one_relations(self, data: InputData[DeclarativeBase, QueryableAttribute[Any]]) -> None:
        for relation in data.relations:
            prop = relation.field.model_field.property
            if (
                not relation.set
                or not isinstance(prop, RelationshipProperty)
                or relation.relation_type is not RelationType.TO_ONE
            ):
                continue
            assert prop.local_remote_pairs
            for local, remote in prop.local_remote_pairs:
                assert local.key
                assert remote.key
                # We take the first input as it's a *ToOne relation
                setattr(relation.parent, local.key, getattr(relation.set[0], remote.key))

    def _create_nested_to_one_relations(self, data: InputData[DeclarativeBase, QueryableAttribute[Any]]) -> None:
        for level in data.filter_by_level(RelationType.TO_ONE, "create"):
            insert_params: defaultdict[type[DeclarativeBase], list[dict[str, Any]]] = defaultdict(list)

            for relation, instance in level.relation_instance_tuples:
                assert relation.field.related_model
                insert_params[relation.field.related_model].append(self._to_dict(instance))

            for model_type, values in insert_params.items():
                results = self.session.execute(
                    insert(model_type).returning(*model_type.__mapper__.primary_key, sort_by_parameter_order=True),
                    values,
                )
                instance_ids = results.all()

                pk_names = [pk.name for pk in model_type.__mapper__.primary_key]

                # Update Pks
                for instance in level.instances:
                    for column in model_type.__mapper__.primary_key:
                        setattr(instance, column.key, instance_ids[pk_names.index(column.key)])

                # Update Fks
                for relation, id_values in zip(level.relations, instance_ids, strict=True):
                    prop = relation.field.model_field.property
                    assert isinstance(prop, RelationshipProperty)
                    assert prop.local_remote_pairs
                    for local, remote in prop.local_remote_pairs:
                        assert local.key
                        assert remote.key
                        setattr(relation.parent, local.key, id_values[pk_names.index(remote.key)])

    def _connect_to_many_relations(
        self, data: InputData[DeclarativeBase, QueryableAttribute[Any]], created_ids: Sequence[Row[Any]]
    ) -> None:
        for level in data.filter_by_level(RelationType.TO_MANY, "set"):
            update_params: defaultdict[type[DeclarativeBase], list[dict[str, Any]]] = defaultdict(list)
            for relation in level.relations:
                prop = relation.field.model_field.property
                assert prop.local_remote_pairs
                assert relation.field.related_model
                parent = created_ids[relation.input_index] if relation.level == 1 else relation.parent
                update_params[relation.field.related_model].extend(
                    [
                        {
                            column.key: getattr(relation_model, column.key)
                            for column in relation_model.__mapper__.primary_key
                        }
                        | {
                            remote.key: getattr(parent, local.key)
                            for local, remote in prop.local_remote_pairs
                            if local.key and remote.key
                        }
                        for relation_model in relation.set
                    ]
                )

            for model_type, values in update_params.items():
                self.session.execute(update(model_type), values)

    def _create_to_many_relations(
        self, data: InputData[DeclarativeBase, QueryableAttribute[Any]], created_ids: Sequence[Row[Any]]
    ) -> None:
        for level in data.filter_by_level(RelationType.TO_MANY, "create"):
            insert_params: defaultdict[type[DeclarativeBase], list[dict[str, Any]]] = defaultdict(list)
            for relation in level.relations:
                prop = relation.field.model_field.property
                assert prop.local_remote_pairs
                assert relation.field.related_model
                parent = created_ids[relation.input_index] if relation.level == 1 else relation.parent
                fks = {
                    remote.key: getattr(parent, local.key)
                    for local, remote in prop.local_remote_pairs
                    if local.key and remote.key
                }
                insert_params[relation.field.related_model].extend(
                    [self._to_dict(mapped) | fks for mapped in relation.create]
                )

            for model_type, values in insert_params.items():
                self.session.execute(insert(model_type), values)

    def _create_many(self, data: InputData[DeclarativeBase, QueryableAttribute[Any]]) -> Sequence[Row[Any]]:
        with self.session.begin_nested() as transaction:
            self._create_nested_to_one_relations(data)
            self._connect_to_one_relations(data)
            result = self.session.execute(
                insert(self.model).returning(*self.model.__mapper__.primary_key),
                [self._to_dict(instance) for instance in data.input_instances],
            )
            instance_ids = result.all()
            self._connect_to_many_relations(data, instance_ids)
            self._create_to_many_relations(data, instance_ids)
            transaction.commit()
        return instance_ids

    def list(
        self,
        selection: SQLAlchemyQueryNode | None = None,
        dto_filter: BooleanFilterDTO[DeclarativeBase, QueryableAttribute[Any]] | None = None,
        order_by: list[OrderByDTO[DeclarativeBase, QueryableAttribute[Any]]] | None = None,
        limit: int | None = None,
        offset: int | None = None,
        distinct_on: list[EnumDTO] | None = None,
        allow_null: bool = False,
        query_hooks: defaultdict[SQLAlchemyQueryNode, list[QueryHook[DeclarativeBase]]] | None = None,
        execution_options: dict[str, Any] | None = None,
        **kwargs: Any,
    ) -> QueryResult[DeclarativeT]:
        executor = self._get_executor(
            executor_type=SyncQueryExecutor,
            selection=selection,
            dto_filter=dto_filter,
            order_by=order_by,
            limit=limit,
            offset=offset,
            distinct_on=distinct_on,
            allow_null=allow_null,
            query_hooks=query_hooks,
            execution_options=execution_options,
        )
        return executor.list(self.session)

    def get_one(
        self,
        selection: SQLAlchemyQueryNode | None = None,
        dto_filter: BooleanFilterDTO[DeclarativeBase, QueryableAttribute[Any]] | None = None,
        order_by: list[OrderByDTO[DeclarativeBase, QueryableAttribute[Any]]] | None = None,
        limit: int | None = None,
        offset: int | None = None,
        distinct_on: list[EnumDTO] | None = None,
        allow_null: bool = False,
        query_hooks: defaultdict[SQLAlchemyQueryNode, list[QueryHook[DeclarativeBase]]] | None = None,
        execution_options: dict[str, Any] | None = None,
        **kwargs: Any,
    ) -> QueryResult[DeclarativeT]:
        executor = self._get_executor(
            executor_type=SyncQueryExecutor,
            selection=selection,
            dto_filter=dto_filter,
            order_by=order_by,
            limit=limit,
            offset=offset,
            distinct_on=distinct_on,
            allow_null=allow_null,
            query_hooks=query_hooks,
            execution_options=execution_options,
            **kwargs,
        )
        return executor.get_one_or_none(self.session)

    def get_by_id(
        self,
        selection: SQLAlchemyQueryNode | None = None,
        query_hooks: defaultdict[SQLAlchemyQueryNode, list[QueryHook[DeclarativeBase]]] | None = None,
        execution_options: dict[str, Any] | None = None,
        **kwargs: Any,
    ) -> QueryResult[DeclarativeT]:
        executor = self._get_executor(
            SyncQueryExecutor, selection=selection, query_hooks=query_hooks, execution_options=execution_options
        )
        executor.base_statement = executor.base_statement.where(
            *[
                field_def.model_field == kwargs.pop(field_def.name)
                for field_def in executor.scope.id_field_definitions(self.model)
            ]
        )
        return executor.get_one_or_none(self.session)

    def create_many(
        self, data: InputData[DeclarativeBase, QueryableAttribute[Any]], selection: SQLAlchemyQueryNode | None = None
    ) -> QueryResult[DeclarativeT]:
        created_ids = self._create_many(data)
        executor = self._get_executor(SyncQueryExecutor, selection=selection)
        id_fields = executor.scope.id_field_definitions(self.model)
        # 6. Get the selection for newly added instances
        instances_ids: dict[str, list[Any]] = {
            field.model_field_name: [getattr(instance, field.model_field_name) for instance in created_ids]
            for field in id_fields
        }
        executor.base_statement = executor.base_statement.where(
            *[field_def.model_field.in_(instances_ids[field_def.model_field_name]) for field_def in id_fields]
        )
        return executor.list(self.session)
